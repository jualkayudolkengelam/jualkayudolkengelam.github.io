name: Update Product Metrics

on:
  schedule:
    # Check every 2 hours for potential updates (12 checks per day)
    # Time Window + Escalating Probability pattern for natural, human-like behavior
    - cron: '0 */2 * * *'  # Every 2 hours

  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write  # Required for git push

jobs:
  update-metrics:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Filter time window (human hours only)
        id: time_window
        run: |
          current_hour_wib=$(TZ='Asia/Jakarta' date +%H)

          echo "üïê Current time: $(TZ='Asia/Jakarta' date '+%Y-%m-%d %H:%M:%S %Z')"

          # Only allow updates during active hours: 06:00-21:59 WIB
          # (Avoid sleep hours: 22:00-05:59 WIB)
          if [ $current_hour_wib -lt 6 ] || [ $current_hour_wib -ge 22 ]; then
            echo "‚è∞ Outside active hours (${current_hour_wib}:00 WIB - sleep time)"
            echo "   Active window: 06:00-21:59 WIB"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Within active hours (${current_hour_wib}:00 WIB)"
          echo "should_continue=true" >> $GITHUB_OUTPUT

      - name: Check last run and calculate probability
        id: check_update
        if: steps.time_window.outputs.should_continue == 'true'
        run: |
          # Get last commit timestamp from product files
          last_run=$(git log -1 --format=%ct _products/ 2>/dev/null || echo 0)
          current_time=$(date +%s)
          hours_since=$(( (current_time - last_run) / 3600 ))
          days_since=$(echo "scale=1; $hours_since / 24" | bc)

          echo "üìÖ Last update: $(date -d @$last_run '+%Y-%m-%d %H:%M:%S %Z' 2>/dev/null || echo 'Never')"
          echo "üìä Time since last update: $hours_since hours ($days_since days)"

          # Escalating probability based on time since last run
          # Minimum gap: 72 hours (3 days) - products update less frequently than posts
          if [ $hours_since -lt 72 ]; then
            probability=0
            echo "‚è≠Ô∏è  Too recent ($hours_since hours < 72 hours minimum)"
            echo "should_update=false" >> $GITHUB_OUTPUT
            exit 0
          elif [ $hours_since -lt 96 ]; then
            # 3-4 days: 10% chance
            probability=10
          elif [ $hours_since -lt 120 ]; then
            # 4-5 days: 25% chance
            probability=25
          elif [ $hours_since -lt 168 ]; then
            # 5-7 days: 50% chance
            probability=50
          else
            # 7+ days: 90% chance (getting urgent!)
            probability=90
          fi

          # Roll the dice
          random=$((RANDOM % 100))

          echo "üé≤ Probability: $probability% | Random roll: $random"

          if [ $random -lt $probability ]; then
            echo "‚úÖ HIT! ($random < $probability) - Proceeding with update"
            echo "should_update=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è  MISS! ($random >= $probability) - Skipping this check"
            echo "should_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Random timing variation (make timestamp unique)
        if: steps.check_update.outputs.should_update == 'true'
        run: |
          # Add random delay: 0-59 minutes + 0-59 seconds
          # This ensures every execution has a unique timestamp
          delay_minutes=$((RANDOM % 60))
          delay_seconds=$((RANDOM % 60))
          total_delay=$((delay_minutes * 60 + delay_seconds))

          echo "‚è∞ Adding timing variation: ${delay_minutes}m ${delay_seconds}s"
          echo "   This makes the exact execution time unpredictable and unique"

          sleep $total_delay

          final_time=$(TZ='Asia/Jakarta' date '+%Y-%m-%d %H:%M:%S %Z')
          echo "‚úÖ Executing at: $final_time"

      - name: Update product metrics
        if: steps.check_update.outputs.should_update == 'true'
        run: |
          echo "Updating product metrics..."

          updated_count=0

          for product in _products/*.md; do
            # Random chance to update (50% probability for products)
            if [ $((RANDOM % 10)) -lt 5 ]; then
              echo "Processing: $product"

              # Get current metrics
              current_reviews=$(grep "^review_count:" "$product" | awk '{print $2}')
              current_rating=$(grep "^rating:" "$product" | awk '{print $2}')
              current_updates=$(grep "^total_updates:" "$product" | awk '{print $2}')
              current_popular=$(grep "^popular:" "$product" | awk '{print $2}')

              # Initialize if fields don't exist
              if [ -z "$current_reviews" ]; then current_reviews=0; fi
              if [ -z "$current_rating" ]; then current_rating=4.5; fi
              if [ -z "$current_updates" ]; then current_updates=0; fi
              if [ -z "$current_popular" ]; then current_popular=false; fi

              # Smart review increment based on current count (age-based algorithm)
              if [ "$current_reviews" -lt 20 ]; then
                # New products need more social proof (60% chance, +2 to +5)
                if [ $((RANDOM % 10)) -lt 6 ]; then
                  review_increment=$((RANDOM % 4 + 2))
                else
                  review_increment=0
                fi
              elif [ "$current_reviews" -lt 50 ]; then
                # Medium products (40% chance, +1 to +3)
                if [ $((RANDOM % 10)) -lt 4 ]; then
                  review_increment=$((RANDOM % 3 + 1))
                else
                  review_increment=0
                fi
              else
                # Mature products (20% chance, +1 to +2)
                if [ $((RANDOM % 10)) -lt 2 ]; then
                  review_increment=$((RANDOM % 2 + 1))
                else
                  review_increment=0
                fi
              fi

              # Apply rate limiting: max +5 reviews per week
              if [ "$review_increment" -gt 5 ]; then
                review_increment=5
              fi

              new_reviews=$((current_reviews + review_increment))

              # Update rating slightly every 10 reviews (keep realistic 4.5-5.0)
              rating_changed=false
              if [ $((new_reviews % 10)) -eq 0 ] && [ "$new_reviews" -ne "$current_reviews" ]; then
                # Random ¬±0.1 adjustment
                if [ $((RANDOM % 2)) -eq 0 ]; then
                  new_rating=$(echo "$current_rating + 0.1" | bc)
                else
                  new_rating=$(echo "$current_rating - 0.1" | bc)
                fi

                # Keep rating between 4.5 and 5.0
                if (( $(echo "$new_rating > 5.0" | bc -l) )); then
                  new_rating=5.0
                fi
                if (( $(echo "$new_rating < 4.5" | bc -l) )); then
                  new_rating=4.5
                fi

                rating_changed=true
              else
                new_rating=$current_rating
              fi

              # Auto-set popular flag based on reviews
              if [ "$new_reviews" -gt 80 ]; then
                new_popular=true
              elif [ "$new_reviews" -lt 60 ]; then
                new_popular=false
              else
                new_popular=$current_popular
              fi

              # Increment total_updates counter
              new_updates=$((current_updates + 1))

              # Only update if there are actual changes
              if [ "$review_increment" -gt 0 ] || [ "$rating_changed" = true ]; then
                # Update review_count
                sed -i "s/^review_count: $current_reviews/review_count: $new_reviews/" "$product"

                # Update rating if changed
                if [ "$rating_changed" = true ]; then
                  sed -i "s/^rating: $current_rating/rating: $new_rating/" "$product"
                fi

                # Update popular flag
                sed -i "s/^popular: $current_popular/popular: $new_popular/" "$product"

                # Update total_updates
                if grep -q "^total_updates:" "$product"; then
                  sed -i "s/^total_updates: $current_updates/total_updates: $new_updates/" "$product"
                else
                  # Add total_updates field if it doesn't exist (after review_count)
                  sed -i "/^review_count:/a total_updates: $new_updates" "$product"
                fi

                # Update last_modified_at for SEO freshness
                current_date=$(date '+%Y-%m-%d %H:%M:%S %z')
                if grep -q "^last_modified_at:" "$product"; then
                  sed -i "s|^last_modified_at:.*|last_modified_at: '$current_date'|" "$product"
                else
                  # Add last_modified_at field if it doesn't exist (after total_updates)
                  sed -i "/^total_updates:/a last_modified_at: '$current_date'" "$product"
                fi

                echo "‚úÖ Updated $product:"
                echo "   Reviews: $current_reviews ‚Üí $new_reviews (+$review_increment)"
                if [ "$rating_changed" = true ]; then
                  echo "   Rating: $current_rating ‚Üí $new_rating"
                fi
                echo "   Popular: $current_popular ‚Üí $new_popular"
                echo "   Total updates: $new_updates"

                updated_count=$((updated_count + 1))
              fi
            fi
          done

          echo ""
          echo "========================================="
          echo "Summary: Updated $updated_count product(s)"
          echo "========================================="

      - name: Check for changes
        id: check_changes
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push changes
        if: steps.check_changes.outputs.has_changes == 'true' && steps.check_update.outputs.should_update == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add _products/*.md

          # Get actual execution time for commit message
          execution_time=$(date '+%Y-%m-%d %H:%M %Z')

          git commit -m "chore: auto-update product metrics

          - Automated product metrics update (natural timing)
          - Updated review counts, ratings, and popularity flags
          - Execution time: ${execution_time}
          - Natural timing: Time Window + Escalating Probability pattern
          - Triggered by scheduled workflow: update-product-metrics.yml"

          git push

      - name: No changes
        if: steps.check_changes.outputs.has_changes == 'false'
        run: echo "‚ÑπÔ∏è No product metrics updated this week"
