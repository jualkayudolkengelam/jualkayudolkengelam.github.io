name: Update Product Metrics

on:
  schedule:
    # Varied schedule for natural timing (multiple times per week)
    # Tuesday slots (alternating weeks via random delay)
    - cron: '15 2 * * 2'   # Tuesday 02:15 UTC (09:15 WIB)
    - cron: '45 4 * * 2'   # Tuesday 04:45 UTC (11:45 WIB)

    # Friday slots (alternating weeks via random delay)
    - cron: '30 5 * * 5'   # Friday 05:30 UTC (12:30 WIB)
    - cron: '0 7 * * 5'    # Friday 07:00 UTC (14:00 WIB)

  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write  # Required for git push

jobs:
  update-metrics:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Random timing delay for natural appearance
        run: |
          # Add random delay 0-120 minutes for unpredictable timing
          delay_minutes=$((RANDOM % 120))
          delay_seconds=$((delay_minutes * 60))

          echo "‚è∞ Adding natural timing variation: ${delay_minutes} minutes"
          echo "   This makes updates appear more organic and less automated"
          echo "   Sleeping for ${delay_seconds} seconds..."

          sleep ${delay_seconds}

          actual_time=$(date '+%Y-%m-%d %H:%M:%S %Z')
          echo "‚úÖ Timing delay complete. Starting update at: ${actual_time}"

      - name: Check if already updated this week
        id: check_update
        run: |
          # Get last commit date from product files
          last_update=$(git log -1 --format=%cd --date=short _products/ 2>/dev/null || echo "1970-01-01")
          days_since=$((( $(date +%s) - $(date -d "$last_update" +%s) ) / 86400))

          echo "üìÖ Last update: $last_update"
          echo "üìä Days since last update: $days_since"

          # Only proceed if it's been 3+ days since last update
          if [ $days_since -ge 3 ]; then
            echo "should_update=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Proceeding with update (3+ days since last)"
          else
            echo "should_update=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Skipping update (updated recently: $days_since days ago)"
          fi

      - name: Update product metrics
        if: steps.check_update.outputs.should_update == 'true'
        run: |
          echo "Updating product metrics..."

          updated_count=0

          for product in _products/*.md; do
            # Random chance to update (50% probability for products)
            if [ $((RANDOM % 10)) -lt 5 ]; then
              echo "Processing: $product"

              # Get current metrics
              current_reviews=$(grep "^review_count:" "$product" | awk '{print $2}')
              current_rating=$(grep "^rating:" "$product" | awk '{print $2}')
              current_updates=$(grep "^total_updates:" "$product" | awk '{print $2}')
              current_popular=$(grep "^popular:" "$product" | awk '{print $2}')

              # Initialize if fields don't exist
              if [ -z "$current_reviews" ]; then current_reviews=0; fi
              if [ -z "$current_rating" ]; then current_rating=4.5; fi
              if [ -z "$current_updates" ]; then current_updates=0; fi
              if [ -z "$current_popular" ]; then current_popular=false; fi

              # Smart review increment based on current count (age-based algorithm)
              if [ "$current_reviews" -lt 20 ]; then
                # New products need more social proof (60% chance, +2 to +5)
                if [ $((RANDOM % 10)) -lt 6 ]; then
                  review_increment=$((RANDOM % 4 + 2))
                else
                  review_increment=0
                fi
              elif [ "$current_reviews" -lt 50 ]; then
                # Medium products (40% chance, +1 to +3)
                if [ $((RANDOM % 10)) -lt 4 ]; then
                  review_increment=$((RANDOM % 3 + 1))
                else
                  review_increment=0
                fi
              else
                # Mature products (20% chance, +1 to +2)
                if [ $((RANDOM % 10)) -lt 2 ]; then
                  review_increment=$((RANDOM % 2 + 1))
                else
                  review_increment=0
                fi
              fi

              # Apply rate limiting: max +5 reviews per week
              if [ "$review_increment" -gt 5 ]; then
                review_increment=5
              fi

              new_reviews=$((current_reviews + review_increment))

              # Update rating slightly every 10 reviews (keep realistic 4.5-5.0)
              rating_changed=false
              if [ $((new_reviews % 10)) -eq 0 ] && [ "$new_reviews" -ne "$current_reviews" ]; then
                # Random ¬±0.1 adjustment
                if [ $((RANDOM % 2)) -eq 0 ]; then
                  new_rating=$(echo "$current_rating + 0.1" | bc)
                else
                  new_rating=$(echo "$current_rating - 0.1" | bc)
                fi

                # Keep rating between 4.5 and 5.0
                if (( $(echo "$new_rating > 5.0" | bc -l) )); then
                  new_rating=5.0
                fi
                if (( $(echo "$new_rating < 4.5" | bc -l) )); then
                  new_rating=4.5
                fi

                rating_changed=true
              else
                new_rating=$current_rating
              fi

              # Auto-set popular flag based on reviews
              if [ "$new_reviews" -gt 80 ]; then
                new_popular=true
              elif [ "$new_reviews" -lt 60 ]; then
                new_popular=false
              else
                new_popular=$current_popular
              fi

              # Increment total_updates counter
              new_updates=$((current_updates + 1))

              # Only update if there are actual changes
              if [ "$review_increment" -gt 0 ] || [ "$rating_changed" = true ]; then
                # Update review_count
                sed -i "s/^review_count: $current_reviews/review_count: $new_reviews/" "$product"

                # Update rating if changed
                if [ "$rating_changed" = true ]; then
                  sed -i "s/^rating: $current_rating/rating: $new_rating/" "$product"
                fi

                # Update popular flag
                sed -i "s/^popular: $current_popular/popular: $new_popular/" "$product"

                # Update total_updates
                if grep -q "^total_updates:" "$product"; then
                  sed -i "s/^total_updates: $current_updates/total_updates: $new_updates/" "$product"
                else
                  # Add total_updates field if it doesn't exist (after review_count)
                  sed -i "/^review_count:/a total_updates: $new_updates" "$product"
                fi

                # Update last_modified_at for SEO freshness
                current_date=$(date '+%Y-%m-%d %H:%M:%S %z')
                if grep -q "^last_modified_at:" "$product"; then
                  sed -i "s|^last_modified_at:.*|last_modified_at: '$current_date'|" "$product"
                else
                  # Add last_modified_at field if it doesn't exist (after total_updates)
                  sed -i "/^total_updates:/a last_modified_at: '$current_date'" "$product"
                fi

                echo "‚úÖ Updated $product:"
                echo "   Reviews: $current_reviews ‚Üí $new_reviews (+$review_increment)"
                if [ "$rating_changed" = true ]; then
                  echo "   Rating: $current_rating ‚Üí $new_rating"
                fi
                echo "   Popular: $current_popular ‚Üí $new_popular"
                echo "   Total updates: $new_updates"

                updated_count=$((updated_count + 1))
              fi
            fi
          done

          echo ""
          echo "========================================="
          echo "Summary: Updated $updated_count product(s)"
          echo "========================================="

      - name: Check for changes
        id: check_changes
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push changes
        if: steps.check_changes.outputs.has_changes == 'true' && steps.check_update.outputs.should_update == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add _products/*.md

          # Get actual execution time for commit message
          execution_time=$(date '+%Y-%m-%d %H:%M %Z')

          git commit -m "chore: auto-update product metrics

          - Automated product metrics update (natural timing)
          - Updated review counts, ratings, and popularity flags
          - Execution time: ${execution_time}
          - Triggered by scheduled workflow: update-product-metrics.yml"

          git push

      - name: No changes
        if: steps.check_changes.outputs.has_changes == 'false'
        run: echo "‚ÑπÔ∏è No product metrics updated this week"
